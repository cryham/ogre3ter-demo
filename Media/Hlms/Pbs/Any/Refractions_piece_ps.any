
#include "/media/matias/Datos/SyntaxHighlightingMisc.h"

@property( hlms_screen_space_refractions )
@piece( DeclRefractionsFuncs )
	midf3 OGRE_refract( midf3 viewDir, midf3 normal, midf refractionIndex, midf NdotV )
	{
		midf3 retVal;
		midf k = _h( 1.0 ) - refractionIndex * refractionIndex * (_h( 1.0 ) - NdotV  * NdotV);
		if( k < _h( 0.0 ) )
			retVal = midf3_c( 0, 0, 0 );
		else
			retVal = -refractionIndex * viewDir - (sqrt( k ) - refractionIndex * NdotV) * normal;
		return retVal;
	}
@end

@piece( applyRefractions )
	@property( !fresnel_scalar )
		midf refractF0 = pixelData.F0;
	@else
		midf refractF0 = max( pixelData.F0.x, pixelData.F0.y, pixelData.F0.z );
	@end

	// refractNormal must be in view space, and we ignore .z component
	midf2 refractNormal2d = OGRE_refract( pixelData.viewDir, pixelData.normal,
										  refractF0, pixelData.NdotV ).xy;
	float2 refractUv = screenPosUv.xy + float2( refractNormal2d.xy ) *
					   float2( material.refractionStrength,
							   material.refractionStrength * passBuf.aspectRatio ) /
					//   ( (-inPs.pos.z + 1.0) * (-inPs.pos.z + 1.0) );  // org - none far, bad near
					//   ( (-inPs.pos.z + 1.0 ) );  // bad close
					//   ( -inPs.pos.z * 0.5 + 2.0);  // strong- near, no far
					//  good
					  ( max(21.0, -inPs.pos.z) * 0.5 + 2.0);  // * big near, no far
					//   ( max(31.0, -inPs.pos.z) * 0.5 + 2.0);  // + ok near, no far
					//   ( max(121.0, -inPs.pos.z) * 0.2 + 2.0);  // ~ soft near, good far
					//   ( max(21.0, -inPs.pos.z) * 0.2 + 2.0);  // - tiny strong near and far
					//  old meh
					//   ( min(-71.0, max(-1.0, -inPs.pos.z)) * 1.0 + 1.0);  // ~ soft near, ok far
					//   ( min(-21.0, max(-11.0, -inPs.pos.z)) * 0.7 + 1.0);  // *- tiny strong
					//   ( min(-41.0, max(-2.0, -inPs.pos.z)) * 0.7 + 1.0);  // ^ nice near, strong far
	midf3 refractionCol = OGRE_SampleLevelF16( refractionMap, refractionMapSampler, refractUv, 0 ).xyz;
	midf refractionDepth = OGRE_SampleLevelF16( depthTextureNoMsaa, refractionMapSampler, refractUv, 0 ).x;

	// We may need to fallback to regular transparency if we're sampling to close to the edges
	// or the object being refracted is in front of us.
	midf3 fallbackRefractionCol = OGRE_Load2DF16( refractionMap, iFragCoord.xy, 0 ).xyz;

	refractUv = saturate( abs( screenPosUv.xy * 2.0 - 1.0 ) * 10.0 - 9.0 );
	midf fallbackRefrW = midf_c( max( refractUv.x, refractUv.y ) );
	fallbackRefrW = fallbackRefrW * fallbackRefrW;

	@property( hlms_no_reverse_depth )
		if( refractionDepth < gl_FragCoord.z - 0.025 )
	@else
		if( refractionDepth > gl_FragCoord.z + 0.025 )
	@end
		{
			// We're trying to refract an object that is in front of us. We can't do that.
			fallbackRefrW = _h( 1.0 );
		}

	refractionCol = lerp( refractionCol, fallbackRefractionCol, fallbackRefrW );
	refractionCol.x *= 0.4f;  // colorize cyan-blue
	refractionCol.y *= 0.9f;
	// refractionCol.x *= refractionDepth * 1.1f;
	// refractionCol.y *= refractionDepth * 2.01f;
	// refractionCol.z *= refractionDepth * 10.05f;

	@property( use_texture_alpha )
		midf refractionAlpha = midf_c( material.F0.w ) * pixelData.diffuse.w;
	@else
		midf refractionAlpha = midf_c( material.F0.w );
	@end

	finalColour += refractionCol.xyz * (_h( 1.0 ) - refractionAlpha);

	
	//  depth ?  ------
	// midf depthValue = OGRE_SampleLevelF16( depthTextureNoMsaa, refractionMapSampler, refractUv, 0 ).x;
	// midf depthValue = texelFetch( depthTextureNoMsaa, gl_FragCoord.x, gl_FragCoord.y );
	// midf3 ndc = float3( gl_FragCoord.xy * 2.0 - 1.0, depthValue );
	// midf4 tmp = mul( inverse( worldViewProj ), midf4( ndc, 1.0f  ) );
	// midf3 restored_inVs_vertex = tmp.xyz / tmp.w;
	// finalColour.xyz = ndc * 0.001;

	// finalColour.z = inPS.pos screenPosUv gl_Position.x;  // no-
	
	// midf3 ndcPos = midf3( gl_FragCoord.xy * passBuf.invWindowRes * 2.0f - 1.0f, refractionDepth );
	// midf4 linearSpacePos = mul( inverse( passBuf.viewProj ), midf4( ndcPos, 1.0f  ) );
	// linearSpacePos /= linearSpacePos.w;

	// finalColour = length(linearSpacePos.z) * midf3(0.001f, 0.0001f, 0.00001f);
	// finalColour = linearSpacePos.xyz * midf3(0.01f, 0.001f, 0.0001f);
	// finalColour = inPs.pos.xyz;
	// finalColour = length(linearSpacePos.xyz) * midf3(0.1f, 0.01f, 0.001f);
	// finalColour = (inPs.pos.xyz - linearSpacePos.xyz) * midf3(0.1f, 0.01f, 0.001f);
	// Now linearSpacePos contains the original position (in camera space) at the given xyz pixel
	// finalColour.z = refractionDepth;  // = 0  ?
@end
@end
